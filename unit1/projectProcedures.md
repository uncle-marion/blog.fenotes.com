> Marion 前端教程 > 前端开发应知应会 > 第一部分 > 前端项目工作流程

### 正常企业中建立一个项目的流程

<img src="../assets/images/unit_01/project_procedures.png">

#### 项目中各种角色

- **PM**：产品经理，也是一个项目的推动者，在有的公司会兼职项目经理的角色或兼职 UE 的角色；

- **UE**：交互设计师，负责页面布局、交互的设计，不负责视图的细节，大部分公司可能是产品经理兼任；

- **UI**：视觉设计师，交互确定之后，设计页面样式（需要注意的是，在很多情况下，UE 和 UI 是同一个人）；

- **RD**：后端开发人员，包括但不限于后端开发、接口开发；

- **CRD**：客户端开发人员，安卓和 ios 都是；

- **FE**：前端开发人员，包括但不限于界面开发、中台开发；

- **QA**：测试人员。

- **OP**：服务器运维人员，负责各项目环境的正常运行并审批项目上线流程。

#### 项目管理工具

项目管理工具是用来统筹项目进度、任务分配及人员考核用的一种工具，正常来说，在企业中项目一旦确认立项后就会在项目管理工具中创建各种任务，比如初期的项目经理编写需求文档、技术负责人编写技术方案到后期的项目测试中的 BUG 解决等，都需要一个方便易用的工具来进行管理。比较常见的项目管理工具有 Jira、禅道、bugzilla、jenkins 等。

- **Jira**：国外老牌的任务管理系统，集项目计划、任务分配、需求管理、缺陷跟踪于一体的软件。它基于 Java 架构的管理系统，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域；

- **禅道**：国货，易软天创出品，集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，是一款功能完备的项目管理软件，完美地覆盖了项目管理的核心流程。

禅道的主要管理思想基于国际流行的敏捷项目管理方式—Scrum。Scrum 是一种注重实效的敏捷项目管理方式，它规定了核心的管理框架  ，但具体的细节还需要团队自行扩充。禅道在遵循其管理方式基础上，又融入了国内研发现状的很多需求，比如 bug 管理，测试用例管理，发布管理，文档管理等。因此禅道不仅仅是一款 scrum 敏捷项目管理工具，更是一款完备的项目管理软件。基于 scrum，又不局限于 scrum。

禅道最大的特色是创造性的将产品、项目、测试这三者的概念明确分开，互相配合，又互相制约。通过需求、任务、bug 来进行交相互动，最终通过项目拿到合格的产品。

我自己用得比较多的是 Jira，但因为种种原因，我暂时提供不了 Jira 的使用环境，所以只能用禅道，不过禅道在目前国内用户还算是比较多吧，所以，就带着大家学习下禅道吧

[禅道 demo](http://101.200.174.100:8080/zentao/my/)

#### 编写技术方案

技术方案，其实只有少量公司会写，因为小型项目用不上，大型项目没时间写。但在规范化的前端开发流程中它又是不可或缺的。那么，技术方案里到底写什么？
技术方案就是写你计划如何实现需求中的功能。拿一个常见的订单评论项目来说，发布功能如何实现？要调用什么接口，输入输出时用什么？要不要考虑 xss 攻击？再如点赞，是先执行动画再调用接口，还是先调用接口再执行动画？还有，你的**代码如何拆解**，分**几个模块**，有哪些核心的方法。这些都要写。技术方案没有一个固定的格式可供参考，因此是否能把技术方案写的清晰且使用，是判断一个人技术能力的标准之一。

[技术方案实例]

#### 评审

技术方案编写完成之后，需要把项目经理、架构师（或者技术负责人）、其他对接的角色（RD CRD）来评审技术方案。由内部人员评审这个方案是不是符合设计原则，有扩展性，以及是否有其他坑（如性能问题，安全漏洞等）。外部对接的角色主要评审接口是否全面，输入输出设计是否合理。

技术方案评审通过之后，就得给 PM 反馈排期了。注意，估算工期一定要留有 buffer ，给自己**留好余地**。有工作经验的人都知道，一个人在一个公司里，一般会同时担任很多的工作，你**不能保证接下来不会有其他功能耽误你的时间**。例如，这个项目你本来预估是 10 人/天工作量，那你最好反馈 12-13 人/天。当然，评审之前反馈排期也可以，只是评审之后反馈，更加靠谱一些。

#### 开发

正常的情况下，我们的开发工作会在评审通过后立刻开始，**UI 绘制界面效果**图，**接口制定接口文档**，前端参考原型图来**创建项目框架和路由管理**等，这些工作都是需要同步进行的。

这个时候的前端开发具体可分为两种情况，第一种情况是整个项目从零开始，我们需要搭建和配置各种环境，搭建项目框架及定制各种工具和组件，创建 Git 远程仓库，然后才是真正的进入界面和功能的开发；另一种情况是在原有的工程中新增或优化的项目，这种情况不需要进行各种配置，直接从 Git 仓库中新建一个分支就可以进入界面和功能的开发；

上面无论哪一种情况，我们最开始的界面设计都是没有可用的 UI 效果图的，所以，我们最初的时候，一般都是参考产品或 UE 提供的原型图来进行界面开发，在开发完成后如果 UI 的效果图仍然未设计完成，我们就需要开始参考接口提供的 Api 文档设计 mock 数据，开发交互与功能。如果有客户端(h5 内嵌至 app 中)的对接，我们还需要用到一些与 native 交互的插件比如 WebViewJavascriptBridge；

为了避免**编写开发文档**，我们还要尽量提供**丰富的代码注释**。很多未经历过规范性产品设计研发过程的程序员，往往以为一个软件项目最关键的就是代码开发，但是真实的项目管理流程中，代码开发只占软件生命周期的 1/6 。所以，作为程序员你要想自己值钱、有不可替代性，就要从整个软件项目的阶段入手，而不仅仅是提高开发能力。

#### 联调

代码开发完成后，需要经过**联调**和**自测**这两个阶段。前面我们说过，在初期开发时，往往会因为多线并行，造成我们在开发界面时使用的是产品的原型图，而开发功能时则是参考接口提供的文档写的 mock 数据，所以，在我们的代码开发完成后，就需要参考 UI 提供的页面效果图对页面元素的布局和细节进行联调，同时参考真实接口返回的数据对功能和交互进行联调。

#### 自测

当所有的开发工作完成，而且经过了仔细的联调后，我们还需要对项目进行自测：对于界面，我们要在多种**浏览器、显示器和移动终端**去测试它的**显示**效果；对于功能和数据，我们要测试各种**网络情况、各种用户误操作和非法操作**的情况下是否可**正常交互**。当我们确认没有错误以后，还需要使用测试同事提供的测试用例，确认所有测试用例通过以后，才能进入下一个环节。

#### 提测

项目经过自测后就可以进行测试了。我们需要将本地完成后的代码提交到远端仓库，然后通知测试同事**应该测试哪个分支，部署到哪个环境，对应的接口环境是否需要重新部署后端服务，是否需要部署 API 服务**等等，最后就是等待测试同事返回测试结果并解决各种问题（BUG）。
每一次测试完成后还需要合并代码到指定分支，再次进入下一个测试环境进行测试。直到测试同事确认没有任何问题且 PM 确认通过。

**开发中常用到的环境**

**开发环境：**指的就是你自己的电脑 +mock 环境 + 测试同事提供的临时调试接口

**测试环境：**一般来说前端除开发环境以外，其它任意环境都是一样的，都是需要执行 build 命令后通过发布脚本部署到某台远程服务器上。区别主要在于接口服务器。测试环境的接口服务器提供的服务与开发环境的测试同事的临时调试接口几乎一致，最大的区别就是一个在开发环境，一个部署到了远端。测试环境的测试主要是为了检查项目是否正常运行，界面是否符合需求，数据的增删改查是否能正常操作。

**预生产环境：**预生产环境的接口数据来自真实生产环境，可能是过去的一段或最新的但已经去除了敏感信息的线上数据。这里需要测试内容与测试环境一致，是在测试环境通过的基础上做更细致与深入的检查，避免上线后出现数据展示不完整或计算失误带来的直接经济损失。

**生产环境：**提供给最终用户使用的项目运行环境，这里所有的数据都是真实的。项目部署到这个环境一般都是灰度发布，即先在某台用户较少的服务器上部署，测试通过后再在所有的服务器上部署。

#### 上线

测试完成后进入上线流程，上线流程相对于之前的流程来说稍复杂一点，在上线前我们需要从当前测试通过的代码分支中打出来一个 release 分支，创建 tag，建立上线任务，提交审批，审批通过后在指定的时间执行上线脚本或执行，更具体的一些操作，我们会在接下来的 版本管理工具 git 中学习到。

#### 从提测到上线的大致流程

<img src="../assets/images/unit_01/publish.png">

---

### 前端工程化相关概念

就目前来说，Web 业务日益复杂化和多元化，前端开发已经由以 WebPage 模式为主转变为以 WebApp 模式为主了。现在随便找个前端项目，都已经不是过去的拼个页面+搞几个 JQuery 插件就能完成的了。而工程一旦复杂了就会产生许多问题: 比如，**如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？**

我们希望能在日常开发中制订一个规范化的前端工作流，很好地规范统一项目的模块化开发和前端资源，让代码的维护和互相协作更加容易更加方便，令前端开发自动化成为一种习惯。同时，让大家能够**释放生产力，提高开发效率，更好更快地完成团队开发以及项目后期维护和扩展**。于是就有了所谓的前端工程化的概念。

#### 一、技术栈选型

所谓前端工程建设的第一项任务就是根据项目特征进行技术选型，基本上现在所有的网站都是使用了某种前端库或者框架，比如 React、Vue、Angular 等，解放了不少生产力，**合理的技术选型**可以为项目节省许多工程量。我们来了解一下为什么要选用 React：

- **1、React 速度很快**

  它并不直接对 DOM 进行操作，引入了一个叫做虚拟 DOM 的概念，安插在 Javascript 逻辑和实际的 DOM 之间，性能好

- **2、跨浏览器兼容**

  虚拟 DOM 帮助我们解决了跨浏览器问题，它为我们提供了标准化的 API，甚至在 IE8 中都是没问题的。

- **3、一切都是 component**

  代码更加模块化，重用代码更容易，可维护性高。

- **4、单向数据流**

  Flux 是一个用于在 JavaScript 应用中创建单向数据层的架构，它随着 React 视图库的开发而被 Facebook 概念化。

- **5、同构、纯粹的 javascript**

  因为搜索引擎的爬虫程序依赖的是服务端响应而不是 JavaScript 的执行，预渲染你的应用有助于搜索引擎优化。

- **6、兼容性好**

  比如使用 RequireJS 来加载和打包，而 Browserify 和 Webpack 适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。

  > Browserify，一个基于 Nodejs 的工具，可以让你使用类似于 Node 的 Require 的方式来组织浏览器端的 Javascript 代码，通过预编译让前端 Javascript 可以直接使用 Node NPM 安装的一些库。

##### 竞品的比较

其实上面的都是网上流传的一些说法，用于应付投资人或老板的说法，其实，在很多项目里，Vue 是要比 React 更快更容易上手的。那么我们使用 React 的真正理由是什么呢？

因为 **react 编程体现的是函数式编程的思想，把组件设计成为纯函数，状态和逻辑通过参数传入，所以，在 React 中是单向数据流**。React 推崇的是**结合 Immutable 来实现数据不可变性**。比如 React 在 setState 后会重新开始新一轮渲染流程，如果 ShouldComponentUpdate 返回的是 true，就继续渲染，否则就不渲染。而 PureComponent 就是重写了 shouldComponentUpdate，然后在里面对 Props 和 State 做了个浅比较。

而 vue 的思想是**响应式**的，也就是说，是基于**数据可变**的，通过对每一个属性建立 Watcher 来监听，当属性发生变化时，响应式地更新对应的虚拟 Dom。

到这里我们应该就能理解，为什么在大企业里的大项目都会使用 React，因为 Vue 的响应机制天生对于大型项目不友好，**当 State 特别多的时候，会生成特别多的 Watcher，导致大量的计算资源用于响应属性变化而造成卡顿**。

#### 二、代码构建工具

大家以为技术栈选型之后基本上就可以开始敲代码了是吧，其实不是的。光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种或多种构建工具，**对代码进行压缩、校验、管理，之后再以页面为单位进行简单的资源合并**。那么，什么是构建工具呢？

构建工具就是我们在上面说的前端工程化的核心思想的体现，将一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。通过构建工具，我们可以很容易地实现下面这些工作：

- **代码转换**：将 TypeScript/es6 编译成 JavaScript、将 scss 编译成 css 等。
- **文件优化**：压缩 JavaScript、css、html 代码，压缩合并图片等。
- **代码分割**：提取多个页面的公共代码，提取首屏不需要执行部分代码让其异步记在。
- **模块合并**：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。
- **自动刷新**：监听本地源代码变化，自动重新构建、刷新浏览器。
- **代码校验**：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。
- **自动发布**：更新代码后，自动构建出线上发布代码并传输给发布系统。

构建工具有很多种，比如 Npm Scripts, Grunt, Gulp, Webpack 等等，因为 create-react-app 使用了 Webpack 作为它的构建工具，所以我们在稍后的课程里会讲一讲 Webpack，今天就先了解一下为什么要使用构建工具就行。

#### 三、了解多页应用与单页应用

- 多页应用，指的是我们的**网站由多个 html 页面构成，每一次页面跳转都需要服务器响应并生成新的内容**

- 单页应用(Single Page App)，指项目中**只有一个 html 页面，每一次页面跳转只是将路由对应的模块读入到当前页面**

- Vue、React 等前端框架都是使用的单页开发模式，因为相对于多页应用，单页应用的页面跳转会更流畅，同时还可以添加各种过场动画

| 多页应用                                                    | 单页应用                                                         |
| ----------------------------------------------------------- | ---------------------------------------------------------------- |
| 项目由多个 html 文件组成                                    | 一个项目只有一个 html 页面                                       |
| 首页加载内容单一相对速度较快，白屏时间很短                  | 首页加载需加载页面文件、工程文件等，白屏时间较长                 |
| 页面跳转需要服务器生成静态文件                              | 页面跳转只需要在客户端载入不同模块                               |
| 每次页面跳转都会删除当前的 dom 树，新页面加载之前会显示空白 | 模块加载完成之前显示之前的模块，加载完成后重新渲染，不会显示空白 |

单页面应用最大的好处就是前后端全部分离，后端不再需要管理前端界面的路由了；其次就是提供了更加快速高效的页面访问速度(当然，它的首页加载变慢了)，使得我们的项目具有了桌面应用的实时性，不再出现页面跳转时的白屏或闪烁的现象；然后就是减少了服务器压力，服务器只需要提供数据而不再需要管理逻辑与页面合成，吞吐能力增加了好几倍。

单页应用的缺陷：

1、 首次加载耗时较长：因为项目文件过大，导致首页因为加载时间较长而造成白屏，影响用户体验。这个问题大方向我们可以采用路由懒加载的方式或使用 Webpack 的按需加载来解决，而对于页面的小方向来说，通过渐进式首页数据加载的方式，比如图片懒加载，比如向下滚动时才加载数据等手段来减少首屏的渲染时间。

2、 单页应用对 Seo 的不友好：单页应用因为页面都是在客户端构建的，是动态的，而机器爬虫只能爬取静态的内容，所以对于各大搜索引擎来说是极不友好的，它们无法读取到你的页面内容。解决这个问题的办法就是使用 ssr，也被称之为同构，思路就是在服务端创建一个 js 引擎并运行这个 html，就像在浏览器里一样，当内容读取完成后再广播一个事件告诉爬虫们，内容已经好了，你可以拿走了。这样爬虫们就拿到了一份完整的 html，跟浏览器中渲染的完全一样，比如 Next.js。

3、 css 命名冲突：使用 sass、less 或 stylus 等 css 预处理器，在一定程度上可以解决这些问题

---

### 课后问题

- 企业中项目的大致流程是怎样的？你参与过这个流程中的哪些步骤？
- 什么是前端工程化？为什么要实现前端工程化？
- 能否说说在前端工程化的过程中，你使用了哪些技术或哪些工具？
- 为什么要使用 react 作为项目的主技术栈，相比于 vue 它好在哪里？
- 什么是构建工具？你知道哪些构建工具？
- 什么是单页应用，它的优缺点是什么，怎样解决？
