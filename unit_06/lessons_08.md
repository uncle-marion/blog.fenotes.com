> 企业框架实战\_第一部分\_TypeScript 入门

### 类

传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链来实现继承，但它仍然缺少一些高级语言中类的方法，比如抽象，比如修饰符等等。

#### 类的访问修饰符

学习什么是类之前，我们需先熟悉类的修饰符，TypeScript 中类的修饰符有三种：
第一种是默认修饰符：public，意义指向是公用，用 public 声明的属性和方法在任何地方都可以被访问到。TypeScript 中默认的修饰符就是 public,无论你是否声明了它。

第二种是完全私有修饰符：private，它是一个完全私有的，用它声明的属性和方法只能在声明它的类的内部使用，其它地方都不可访问。

第三种是受保护的修饰符：protected，它介于 public 与 private 之间，仅在声明它的类和子类中允许访问。

```javascript

// 抽象类
abstract class Animal {
  // 受保护的属性：子类可见
  protected name: string;
  // 私用属性：只有类内部可见
  private age: number;
  constructor(name: string, age?: number) {
    this.name = name;
    if (age) {
      this.age = age;
    }
  }
  // 抽象方法
  abstract sayHello(msg: string): void
}
// Animal的子类
class Cat extends Animal {
  // 公用属性：所有的地方都可以访问
  public sayHello(msg: string): void {
    console.log(`Hello, ${this.name}! ${msg}`);
  }
}
// 实例化一个Cat类
let Tom = new Cat('Tom');
Tom.sayHello('have you eaten?');

```

#### 什么是类

虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类。类，可以简单地解释成，类就是对象的模板，所有的对象都可以通过对类的实例化来生成。

- 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法
- 对象（Object）：类的实例，通过 new 生成
- 面向对象（OOP）的三大特性：封装、继承、多态
- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据
- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性
- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat
- 存取器（getter & setter）：用以改变属性的读取和赋值行为
- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法
- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口

#### 什么是抽象类

抽象类，这是 TypeScript 中模仿其它高级语言增加的一个新概念，定义抽象类的意义在于：必须被子类继承，是半成品，用于衍生出子类，把子类中公共的部分提取出来，封装在顶部，易于维护或扩展。抽象类是提供给其他类继承的基类，抽象类本身不允许被实例化。抽象类中的抽象方法必须在子类中被实现。
抽象类的关键字是 abstract。

#### 类与对象的区别

类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。比如：“动物”是一个类，而“猫”则是“动物”的一个实例。

类的属性与方法是共享的，一个实例能访问它所属类的公共方法和属性；而对象中的方法与属性属于单个对象，除共享了所在类中的方法与属性外，不同对象还会有不同的方法与属性。

#### 类的构造函数

构造函数作为类的核心内容，是每个类实例化对象时 new 指令直接调用的方法，实际上 TypeScript 与 ES6 在这方面并没有差别，如果了解 ES6 的话我们都知道 class 只是一个语法糖，它的底层实现还是 function，类中的构造函数就是 ES5 的方法主体，它最终被赋给该方法原型上的 constructor 属性，而类中实现的一系列的修饰符和特性最后都会被解析为类自身或者原型上的属性和方法，用来配合主体方法实现对象实例的构造。

#### 在类中定义属性与方法

#### 类的静态属性

关于静态属性与静态方法，这个是在 ES7 中被提出来的，TypeScript 实现了它们。我们可以使用 static 修饰符来声明它们，使得它们无须实例化就可以被调用，同时，实例化对象就再也无法访问到它们了：

为什么要定义静态属性或方法呢？其实就像 const 一样，静态属性与方法仅在声明类时进行赋值，而后再也没有谁可以改变它，保持了它的纯洁性。无论何时调用它，给你的值都是固定的。

#### 类的只读属性

在 TypeScript 中，还实现了类的只读属性，类的只读属性只允许在被实例化时进行赋值，

#### 类的继承

#### 类的类型声明

类的类型声明与接口类似，将类本身的名字做为类型声明即可，但要注意的是，实例化对象声明的类型其内部所对应的属性与方法只能是被声明的这个类中的属性与方法。
